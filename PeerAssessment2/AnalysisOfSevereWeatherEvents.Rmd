# Comparison of storms and other severe weather events on fatalities, injuries, and property damages


## Synopsis

> Synopsis: Immediately after the title, there should be a **synopsis** which
> describes and summarizes your analysis in at **most 10 complete sentences**.

**To be completed**


## Data Processing

Load packages.
  
```{r}
packages <- c("data.table", "ggplot2", "xtable")
sapply(packages, require, character.only=TRUE, quietly=TRUE)
```

Fix URL reading for knitr. See [Stackoverflow](http://stackoverflow.com/a/20003380).

```{r}
setInternet2(TRUE)
```

### Download and unzip files

**Don't run this subsection during testing**

Download the storm data documentation files.

* National Weather Service [Storm Data Documentation](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf)
* National Climatic Data Center Storm Events [FAQ](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf)

```{r, eval=FALSE}
url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf"
f <- file.path(getwd(), "StormDataDocumentation.pdf")
download.file(url, f, mode="wb")
url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf"
f <- file.path(getwd(), "StormEventsFAQ.pdf")
download.file(url, f, mode="wb")
```

Download the zipped [storm data file](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2).

```{r, eval=FALSE}
url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
f <- file.path(getwd(), "StormData.csv.bz2")
download.file(url, f, mode="wb")
```

Unzip the data file.

```{r, eval=FALSE}
executable <- file.path("C:", "Program Files", "7-Zip", "7z.exe")
parameters <- "x"
switch <- "-aoa"
cmd <- paste(paste0("\"", executable, "\""), parameters, paste0("\"", f, "\""), switch)
cmd
system(cmd)
```


### Read data file

The data file (CSV format) is in the working directory.
Read the CSV file as a data frame.
Then convert to a data table.

```{r, cache=TRUE}
f <- file.path(getwd(), "StormData.csv.bz2")
D <- read.csv(f, stringsAsFactors=FALSE)
D <- data.table(D)
str(D)
```


### Clean data

Rename the variables to lowercase for ease of coding.

```{r}
old <- names(D)
new <- tolower(old)
setnames(D, old, new)
```

Convert the `bgn_date` character class variable to a date class variable.

```{r}
bgn_date <- strsplit(D$bgn_date, "[^[:digit:]]")
bgn_date <- unlist(bgn_date)
bgn_date <- as.numeric(bgn_date)
bgn_date <- matrix(bgn_date, nrow=nrow(D), byrow=TRUE)
dateStr <- sprintf("%4d%02d%02d", bgn_date[, 3], bgn_date[, 1], bgn_date[, 2])
D <- D[, beginDate := as.Date(dateStr, format="%Y%m%d")]
```

Scale the property damage variable into a new variable, `propertyDamage`.

* If `propdmgexp` = `B`, then multiply `propdmg` by 1,000,000,000
* Else if `propdmgexp` = `M`, then multiply `propdmg` by 1,000,000
* Else if `propdmgexp` = `K`, then multiply `propdmg` by 1,000
* Else if `propdmgexp` = `H`, then multiply `propdmg` by 100
* Else leave `propdmg` as-is

```{r}
D <- D[, propdmgexp := toupper(propdmgexp)]
D[, .N, propdmgexp]
D <- D[, propertyDamage := ifelse(propdmgexp == "B", propdmg * 1E9, ifelse(propdmgexp == "M", propdmg * 1E6, ifelse(propdmgexp == "K", propdmg * 1E3, ifelse(propdmgexp == "H", propdmg * 1E2, propdmg))))]
summary(D$propertyDamage)
```

Scale the crop damage variable into a new variable, `cropDamage`.

* If `cropdmgexp` = `B`, then multiply `cropdmg` by 1,000,000,000
* Else if `cropdmgexp` = `M`, then multiply `cropdmg` by 1,000,000
* Else if `cropdmgexp` = `K`, then multiply `cropdmg` by 1,000
* Else leave `cropdmg` as-is

```{r}
D <- D[, cropdmgexp := toupper(cropdmgexp)]
D[, .N, cropdmgexp]
D <- D[, cropDamage := ifelse(cropdmgexp == "B", cropdmg * 1E9, ifelse(cropdmgexp == "M", cropdmg * 1E6, ifelse(cropdmgexp == "K", cropdmg * 1E3, cropdmg)))]
summary(D$cropDamage)
```


#### Group event types

List the number of unique values of `evtype`.
The number of unique values is too large to manage without some grouping.

```{r}
message(sprintf("Number of unique values of evtype: %.0d", length(unique(D$evtype))))
```

Group event types to mimic the categories found in the [2009 Annual Summaries](http://www.ncdc.noaa.gov/oa/climate/sd/annsum2009.pdf) on page 3.

`evtype` needs a lot of data cleaning.
Particularly, values need to be grouped to resolve spelling variations.
Also, records can have multiple events listed in the `evtype` variable.
Create indicator variables for common event types.

Define a helper function `freqtab` to help with grouping `evtype` values.

```{r}
indicator <- function (regex) {
	indicator <- grepl(regex, D$evtype, ignore.case=TRUE)
	uniqueEventTypes <- unique(D[indicator, evtype])
	show(uniqueEventTypes[order(uniqueEventTypes)])
	indicator
}
```

Create an indicators for variations of **Lightning**, **Tornado**, **Thunderstorm Wind**, and **Hail**.
List the event types that fall into the category of **Convection**.

```{r}
regexLightning <- "\\bL\\S+?G\\b"
regexTornado <- "(NADO)|(\\bTOR\\S+?O\\b|(\\bFUN))"
regexThunderstorm <- "THUNDERSTORM|TSTM"
regexWind <- "(WIND)|(WND)"
regexHail <- "HAIL"
regex <- paste(regexLightning, regexTornado, regexThunderstorm, regexWind, regexHail, sep="|")
D <- D[, eventConvection := indicator(regex)]
```

Create an indicators for variations of **Cold** and **Heat**.
List the event types that fall into the category of **Extreme Temperatures**.

```{r}
regex <- "COLD|HEAT"
D <- D[, eventExtremeTemp := indicator(regex)]
```

Create an indicators for variations of **Flood** and **Rain**.
List the event types that fall into the category of **Flood**.

```{r}
regexFlood <- "(\\bFL\\S+?D)"
regexRain <- "RAIN|PRECIP|SHOWER"
regex <- paste(regexFlood, regexRain, sep="|")
D <- D[, eventFlood := indicator(regex)]
```

Create an indicator for variations of **Snow**, **Ice**, **Freeze**, or **Winter Weather**.
List the event types that fall into the category of **Winter**.

```{r}
regex <- "(SNOW)|(ICE)|(ICY)|(FREEZ)|(WINT)"
D <- D[, eventWinter := indicator(regex)]
```

Calculate the proportion of records that don't satisfy any one of the defined indicators.
Calculate the number of unique event types among these records.
List the ungrouped unique event types.

```{r}
where <- expression(eventConvection == FALSE & eventExtremeTemp == FALSE & eventFlood == FALSE & eventWinter == FALSE)
ungrouped <- D[eval(where), list(n = .N, prop = .N / nrow(D))]
prop <- D[eval(where), .N / nrow(D)]
message(sprintf("Number (%%) of records that don't satisfy any one of the defined indicators: %.0d (%.2f%%)", ungrouped$n, ungrouped$prop * 100))
uniqueEvtype <- unique(D[eval(where), evtype])
message(sprintf("Number of unique event types that don't satisfy any one of the defined indicators: %.0d", length(uniqueEvtype)))
uniqueEvtype[order(uniqueEvtype)]
```

Create an **Other** indicator for ungrouped event types.

```{r}
D <- D[, eventOther := eventConvection == FALSE & eventExtremeTemp == FALSE & eventFlood == FALSE & eventWinter == FALSE]
```

A crosstabulation for the event type categories is below.

```{r}
groupby <- expression(list(eventConvection, eventExtremeTemp, eventFlood, eventWinter, eventOther))
D[, .N, eval(groupby)][order(eventConvection, eventExtremeTemp, eventFlood, eventWinter, eventOther, decreasing=TRUE)]
```

#### Categorize event types

Now that event types are grouped, set up a categorization hierarchy of event
types.
The hierarchy is needed because records can have multiple events listed in the
`evtype` variable.
E.g., *THUNDERSTORM WINDS/FLASH FLOOD*.

The hierarchy is as follows.

1. Convection (including lightning, tornado, thunderstorm, wind, and hail)
2. Extreme temperature (including hot and cold)
3. Flood (including flood, flash flood, rain)
4. Winter (including snow, ice, freeze, or winter weather)
5. Other

Under this categorization hierarchy, the example event type of *THUNDERSTORM
WINDS/FLASH FLOOD* would be assigned to the *Convection* category.
I.e., higher categories outrank lower categories.

```{r}
D <- D[, eventCategory := ifelse(eventConvection, 1, ifelse(eventExtremeTemp, 2, ifelse(eventFlood, 3, ifelse(eventWinter, 4, ifelse(eventOther, 5, NA)))))]
labels <- c("Convection", "Extreme temperature", "Flood", "Winter", "Other")
D <- D[, eventCategory := factor(eventCategory, labels=labels)]
D[, .N, eventCategory]
```


### Restrict date range

The date ranges for each category are below.

```{r}
select <- expression(list(numberEvents = .N, minDate = min(beginDate), maxDate = max(beginDate)))
groupby <- expression(list(eventCategory))
tabEventCategory <- D[, eval(select), eval(groupby)]
tabEventCategory <- tabEventCategory[order(eventCategory)]
message(sprintf("Convection events reach as far back as %.0d.", year(min(D$beginDate[D$eventCategory == "Convection"]))))
message(sprintf("However, the other categories only reach as far back as %.0d.", year(min(D$beginDate[D$eventCategory != "Convection"]))))
```

```{r}
minYear <- year(min(D$beginDate[D$eventCategory != "Convection"]))
maxYear <- year(max(D$beginDate))
D <- D[minYear <= year(beginDate) & year(beginDate) <= maxYear]
message(sprintf("For the purpose of this analysis, the date range will be limited to %.0d to %.0d.", minYear, maxYear))
```


## Results

The following outcomes are reported.

* Total number of fatalities
* Total number of injuries
* Property damage, in terms of dollars


### By event category

The outcomes by event type category are tabulated below.

```{r}
select <- expression(list(numberEvents = format(.N, big.mark=","), fatalities = format(sum(fatalities), big.mark=","), injuries = format(sum(injuries), big.mark=","), propertyDamage = sprintf("$%s billion", format(round(sum(propertyDamage) / 1E9, digits=1), big.mark=","))))
groupby <- expression(list(eventCategory))
tabEventCategory <- D[, eval(select), eval(groupby)]
tabEventCategory <- tabEventCategory[order(eventCategory)]
```

Show the tabulation.

```{r, results='asis'}
print(xtable(tabEventCategory, digits=0), type="html", include.rownames=FALSE)
```


### By event category and year

The outcomes by event type category and year are below.

```{r}
select <- expression(list(numberEvents = .N, fatalities = sum(fatalities, na.rm=TRUE), injuries = sum(injuries, na.rm=TRUE), propertyDamage = sum(propertyDamage, na.rm=TRUE)))
groupby <- expression(list(eventCategory, year(beginDate)))
tabEventCategoryYear <- D[, eval(select), eval(groupby)]
tabEventCategoryYear <- tabEventCategoryYear[order(eventCategory, year)]
```

Find the maximum values for each outcome.

```{r}
maxFatalities <- tabEventCategoryYear[, max(fatalities)]
maxInjuries <- tabEventCategoryYear[, max(injuries)]
maxPropertyDamage <- tabEventCategoryYear[, max(propertyDamage)]
```

Plot each outcome using small multiples and summarize.

```{r fatalities, fig.width=10}
ggplot(tabEventCategoryYear, aes(x=year, y=fatalities, fill=eventCategory)) +
  geom_area(alpha=1/2) +
	scale_fill_brewer(name="Category", palette="Set1") +
  facet_wrap(~ eventCategory, nrow=2, ncol=3) +
	labs(title="Fatalities", x="Year", y="Number") +
	theme(legend.position="none")
```
The category with the most fatalities was *`r tabEventCategoryYear[fatalities == maxFatalities, eventCategory]`* with `r maxFatalities` fatalities in `r tabEventCategoryYear[fatalities == maxFatalities, year]`.
This is the year of the [Chicago heat wave](http://en.wikipedia.org/wiki/1995_Chicago_heat_wave).

```{r injuries, fig.width=10}
ggplot(tabEventCategoryYear, aes(x=year, y=injuries, fill=eventCategory)) +
  geom_area(alpha=1/2) +
  scale_fill_brewer(name="Category", palette="Set1") +
  facet_wrap(~ eventCategory, nrow=2, ncol=3) +
	labs(title="Injuries", x="Year", y="Number") +
	theme(legend.position="none")
```

The category with the most injuries was *`r tabEventCategoryYear[injuries == maxInjuries, eventCategory]`* with `r maxInjuries` injuries in `r tabEventCategoryYear[injuries == maxInjuries, year]`.

```{r propertydamage, fig.width=10}
ggplot(tabEventCategoryYear, aes(x=year, y=propertyDamage / 1E3, fill=eventCategory)) +
  geom_area(alpha=1/2) +
  scale_fill_brewer(name="Category", palette="Set1") +
  facet_wrap(~ eventCategory, nrow=2, ncol=3) +
	labs(title="Property damage", x="Year", y="$ (thousands)") +
	theme(legend.position="none")
```

The category with the most property damage was *`r tabEventCategoryYear[propertyDamage == maxPropertyDamage, eventCategory]`* with `r sprintf("$%s billion", format(round(maxPropertyDamage / 1E9, digits=1), big.mark=","))` in damage in `r tabEventCategoryYear[propertyDamage == maxPropertyDamage, year]`.
This was the year of significant flooding of the [Mid-Atlantic region](http://en.wikipedia.org/wiki/Mid-Atlantic_United_States_flood_of_2006).
