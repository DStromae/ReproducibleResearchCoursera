# Analysis of Severe Weather Events

> Title: Your document should have a title that **briefly** summarizes your data
> analysis

Peer assessment 2 assignment for Coursera course [Reproducible Research](Reproducible Research).


## Synopsis

> Synopsis: Immediately after the title, there should be a **synopsis** which
> describes and summarizes your analysis in at **most 10 complete sentences**.

**To be completed**

> ## Introduction
> 
> Storms and other severe weather events can cause both public health and economic
> problems for communities and municipalities. Many severe events can result in
> fatalities, injuries, and property damage, and preventing such outcomes to the
> extent possible is a key concern.
> 
> This project involves exploring the U.S. National Oceanic and Atmospheric
> Administration's (NOAA) storm database. This database tracks characteristics of
> major storms and weather events in the United States, including when and where
> they occur, as well as estimates of any fatalities, injuries, and property
> damage.
> 


## Data Processing

> The events in the database start in the year 1950 and end in November 2011. In
> the earlier years of the database there are generally fewer events recorded,
> most likely due to a lack of good records. More recent years should be
> considered more complete.

Load packages.
  
```{r}
packages <- c("data.table", "ggplot2", "xtable")
sapply(packages, require, character.only=TRUE, quietly=TRUE)
```

Fix URL reading for knitr. See [Stackoverflow](http://stackoverflow.com/a/20003380).

```{r}
setInternet2(TRUE)
```

### Download and unzip files

**Don't run this subsection during testing**

Download the storm data documentation files.

* National Weather Service [Storm Data Documentation](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf)
* National Climatic Data Center Storm Events [FAQ](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf)

```{r, eval=FALSE}
url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf"
f <- file.path(getwd(), "StormDataDocumentation.pdf")
download.file(url, f, mode="wb")
url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf"
f <- file.path(getwd(), "StormEventsFAQ.pdf")
download.file(url, f, mode="wb")
```

Download the zipped [storm data file](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2).

```{r, eval=FALSE}
url <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
f <- file.path(getwd(), "StormData.csv.bz2")
download.file(url, f, mode="wb")
```

Unzip the data file.

```{r, eval=FALSE}
executable <- file.path("C:", "Program Files", "7-Zip", "7z.exe")
parameters <- "x"
switch <- "-aoa"
cmd <- paste(paste0("\"", executable, "\""), parameters, paste0("\"", f, "\""), switch)
cmd
system(cmd)
```


### Read data file

The data file (CSV format) is in the working directory.
Read the CSV file as a data frame.
Then convert to a data table.

```{r, cache=TRUE}
f <- file.path(getwd(), "StormData.csv.bz2")
D <- read.csv(f, stringsAsFactors=FALSE)
D <- data.table(D)
str(D)
```


### Clean data

Rename the variables to lowercase for ease of coding.

```{r}
old <- names(D)
new <- tolower(old)
setnames(D, old, new)
```

Convert the `bgn_date` character class variable to a date class variable.

```{r}
bgn_date <- strsplit(D$bgn_date, "[^[:digit:]]")
bgn_date <- unlist(bgn_date)
bgn_date <- as.numeric(bgn_date)
bgn_date <- matrix(bgn_date, nrow=nrow(D), byrow=TRUE)
dateStr <- sprintf("%4d%02d%02d", bgn_date[, 3], bgn_date[, 1], bgn_date[, 2])
D <- D[, beginDate := as.Date(dateStr, format="%Y%m%d")]
```

Scale the property damage variable into a new variable, `propertyDamage`.

* If `propdmgexp` = `B`, then multiply `propdmg` by 1,000,000,000
* Else if `propdmgexp` = `M`, then multiply `propdmg` by 1,000,000
* Else if `propdmgexp` = `K`, then multiply `propdmg` by 1,000
* Else if `propdmgexp` = `H`, then multiply `propdmg` by 100
* Else leave `propdmg` as-is

```{r}
D <- D[, propdmgexp := toupper(propdmgexp)]
D[, .N, propdmgexp]
D <- D[, propertyDamage := ifelse(propdmgexp == "B", propdmg * 1E9, ifelse(propdmgexp == "M", propdmg * 1E6, ifelse(propdmgexp == "K", propdmg * 1E3, ifelse(propdmgexp == "H", propdmg * 1E2, propdmg))))]
summary(D$propertyDamage)
```

Scale the crop damage variable into a new variable, `cropDamage`.

* If `cropdmgexp` = `B`, then multiply `cropdmg` by 1,000,000,000
* Else if `cropdmgexp` = `M`, then multiply `cropdmg` by 1,000,000
* Else if `cropdmgexp` = `K`, then multiply `cropdmg` by 1,000
* Else leave `cropdmg` as-is

```{r}
D <- D[, cropdmgexp := toupper(cropdmgexp)]
D[, .N, cropdmgexp]
D <- D[, cropDamage := ifelse(cropdmgexp == "B", cropdmg * 1E9, ifelse(cropdmgexp == "M", cropdmg * 1E6, ifelse(cropdmgexp == "K", cropdmg * 1E3, cropdmg)))]
summary(D$cropDamage)
```


#### Group event types

List the number of unique values of `evtype`.
The number of unique values is too large to manage without some grouping.

```{r}
message(sprintf("Number of unique values of evtype: %.0d", length(unique(D$evtype))))
```

Group event types to mimic the categories found in the [2009 Annual Summaries](http://www.ncdc.noaa.gov/oa/climate/sd/annsum2009.pdf) on page 3.

`evtype` needs a lot of data cleaning.
Particularly, values need to be grouped to resolve spelling variations.
Also, records can have multiple events listed in the `evtype` variable.
Create indicator variables for common event types.

Define a helper function `freqtab` to help with grouping `evtype` values.

```{r}
indicator <- function (regex) {
	indicator <- grepl(regex, D$evtype, ignore.case=TRUE)
	uniqueEventTypes <- unique(D[indicator, evtype])
	show(uniqueEventTypes[order(uniqueEventTypes)])
	indicator
}
```

Create an indicators for variations of **Lightning**, **Tornado**, **Thunderstorm Wind**, and **Hail**.
These fall into the top-level category of **Convection**.

```{r}
regexLightning <- "\\bL\\S+?G\\b"
regexTornado <- "(NADO)|(\\bTOR\\S+?O\\b|(\\bFUN))"
regexThunderstorm <- "THUNDERSTORM|TSTM"
regexWind <- "(WIND)|(WND)"
regexHail <- "HAIL"
regex <- paste(regexLightning, regexTornado, regexThunderstorm, regexWind, regexHail, sep="|")
D <- D[, eventConvection := indicator(regex)]
```

Create an indicators for variations of **Cold** and **Heat**.
These fall into the top-level category of **Extreme Temperatures**.

```{r}
regex <- "COLD|HEAT"
D <- D[, eventExtremeTemp := indicator(regex)]
```

Create an indicators for variations of **Flood** and **Rain**.
These fall into the top-level category of **Flood**.

```{r}
regexFlood <- "(\\bFL\\S+?D)"
regexRain <- "RAIN|PRECIP|SHOWER"
regex <- paste(regexFlood, regexRain, sep="|")
D <- D[, eventFlood := indicator(regex)]
```

Create an indicator for variations of **Snow**, **Ice**, **Freeze**, or **Winter Weather**.
These fall into the top-level category of **Winter**.

```{r}
regex <- "(SNOW)|(ICE)|(ICY)|(FREEZ)|(WINT)"
D <- D[, eventWinter := indicator(regex)]
```

Calculate the proportion of records that don't satisfy any one of the defined indicators.
Calculate the number of unique event types among these records.
List the ungrouped unique event types.

```{r}
where <- expression(eventConvection == FALSE & eventExtremeTemp == FALSE & eventFlood == FALSE & eventWinter == FALSE)
ungrouped <- D[eval(where), list(n = .N, prop = .N / nrow(D))]
prop <- D[eval(where), .N / nrow(D)]
message(sprintf("Number (%%) of records that don't satisfy any one of the defined indicators: %.0d (%.2f%%)", ungrouped$n, ungrouped$prop * 100))
uniqueEvtype <- unique(D[eval(where), evtype])
message(sprintf("Number of unique event types that don't satisfy any one of the defined indicators: %.0d", length(uniqueEvtype)))
uniqueEvtype[order(uniqueEvtype)]
```

Create an **Other** indicator for ungrouped event types.

```{r}
D <- D[, eventOther := eventConvection == FALSE & eventExtremeTemp == FALSE & eventFlood == FALSE & eventWinter == FALSE]
```

According to the [FAQ](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf), 

> An Event is an individual type of storm event. (Thunderstorm Wind, Hail,
> Tornado and Flood are events)

A crosstabulation for these events is below.

```{r}
groupby <- expression(list(eventConvection, eventExtremeTemp, eventFlood, eventWinter, eventOther))
D[, .N, eval(groupby)][order(eventConvection, eventExtremeTemp, eventFlood, eventWinter, eventOther, decreasing=TRUE)]
```

#### Categorize event types

Now that event types are grouped, set up a categorization hierarchy of event
types.
The hierarchy is needed because records can have multiple events listed in the
`evtype` variable.
E.g., *THUNDERSTORM WINDS/FLASH FLOOD*.

The hierarchy is as follows.

1. Convection (including lightning, tornado, thunderstorm, wind, and hail)
2. Extreme temperature (including hot and cold)
3. Flood (including flood, flash flood, rain)
4. Winter (including snow, ice, freeze, or winter weather)
5. Other

Under this categorization hierarchy, the example event type of *THUNDERSTORM
WINDS/FLASH FLOOD* would be assigned to the *Convection* category.

```{r}
D <- D[, eventCategory := ifelse(eventConvection, 1, ifelse(eventExtremeTemp, 2, ifelse(eventFlood, 3, ifelse(eventWinter, 4, ifelse(eventOther, 5, NA)))))]
labels <- c("Convection", "Extreme temperature", "Flood", "Winter", "Other")
D <- D[, eventCategory := factor(eventCategory, labels=labels)]
D[, .N, eventCategory]
```


## Results

> ### Questions
> 
> Your data analysis must address the following questions:
> 
> Across the United States, which types of events (as indicated in the `EVTYPE`
> variable) are most harmful with respect to popuulation health?
> 
> Across the United States, which types of events have the greatest economic
> consequences?
> 
> Consider writing your report as if it were to be read by a government or
> municipal manager who might be responsible for preparing for severe weather
> events and will need to prioritize resources for different types of events.
> However, there is no need to make any specific recommendations in your report.
> 
> The analysis document must have **at least one figure containing as plot**.
> 
> Your analyis must have **no more than three figures**. Figures may have multiple
> plots in them (i.e. panel plots), but there cannot be more than three figures
> total.
> 

### Outcomes

The following outcomes are reported.

* Total number of fatalities
* Total number of injuries
* Property damage, in terms of dollars


### By event category

Tabulate the outcomes by event type category.

```{r}
select <- expression(list(numberEvents = .N, fatalities = sum(fatalities), injuries = sum(injuries), propertyDamage = sum(propdmg)))
groupby <- expression(list(eventCategory))
tabEventCategory <- D[, eval(select), eval(groupby)]
tabEventCategory <- tabEventCategory[order(eventCategory)]
```

Show the tabulation.

```{r, results='asis'}
print(xtable(tabEventCategory, digits=0), type="html", include.rownames=FALSE)
```


### By event category and year

Tabulate the outcomes by event type category and year.

```{r}
select <- expression(list(numberEvents = .N, fatalities = sum(fatalities), injuries = sum(injuries), propertyDamage = sum(propdmg)))
groupby <- expression(list(eventCategory, year(beginDate)))
tabEventCategoryYear <- D[, eval(select), eval(groupby)]
tabEventCategoryYear <- tabEventCategoryYear[order(eventCategory, year)]
```

Plot the data.

```{r fatalities}
ggplot(tabEventCategoryYear, aes(x=year, y=fatalities, color=eventCategory)) +
	geom_line() +
	scale_color_brewer(name="Category", palette="Set1") +
	labs(title="Fatalities", x="Year", y="Number") +
	theme(legend.position="bottom")
```

```{r injuries}
ggplot(tabEventCategoryYear, aes(x=year, y=injuries, color=eventCategory)) +
	geom_line() +
	scale_color_brewer(name="Category", palette="Set1") +
	labs(title="Injuries", x="Year", y="Number") +
	theme(legend.position="bottom")
```

```{r propertydamage}
ggplot(tabEventCategoryYear, aes(x=year, y=propertyDamage / 1E3, color=eventCategory)) +
	geom_line() +
	scale_color_brewer(name="Category", palette="Set1") +
	labs(title="Property damage", x="Year", y="$ (thousands)") +
	theme(legend.position="bottom")
```
